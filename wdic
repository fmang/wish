#!/usr/bin/perl -CA

use strict;
use warnings;
use utf8;

use File::Path qw(make_path);
use Getopt::Long qw(:config no_auto_abbrev);
use Term::ANSIColor;
use Wish::Edict2;
use Wish::KanjiDic;

binmode(STDOUT, ":utf8");

my $dbdir = 'db';
my $load_mode;
my @kanjidic_files;
my @edict_files;
my $use_colors = -t STDOUT;
my $show_homophones = 1;

GetOptions(
	'database|db|d=s' => \$dbdir,
	'load|l' => \$load_mode,
	'kanjidic=s' => \@kanjidic_files,
	'edict=s' => \@edict_files,
	'color!' => \$use_colors,
	'homophones!' => \$show_homophones,
);

if (!$load_mode and @kanjidic_files || @edict_files) {
	die("Cannot load a dictionary file without --load.\n");
}

if ($load_mode and @ARGV) {
	die("Please don't load and search at the same time.\n");
}

if (!$load_mode and !@ARGV) {
	print("Nothing to do.\n");
	exit(0);
}

if ($load_mode && ! -d $dbdir) {
	print(STDERR "Creating the database directory $dbdir...\n");
	make_path($dbdir);
}

my $kanjidic = Wish::KanjiDic->new($dbdir, readonly => !$load_mode);
my $edict = Wish::Edict2->new($dbdir, readonly => !$load_mode);

$kanjidic && $edict or die("Couldn't open the dictionary database: $!.\n");

for my $file (@kanjidic_files) {
	print(STDERR "Loading KANJIDIC from $file...\n");
	my $s = $kanjidic->load($file);
	$s or warn("Couldn't load KANJIDIC from $file: $!.\n");
	$s and print(STDERR "Successfully loaded KANJIDIC from $file.\n");
}

for my $file (@edict_files) {
	print(STDERR "Loading EDICT2 from $file...\n");
	my $s = $edict->load($file);
	$s or warn("Couldn't load EDICT2 from $file: $!.\n");
	$s and print(STDERR "Successfully loaded EDICT2 from $file.\n");
}

if ($load_mode) {
	# work is done
	exit(0);
}

################################################################################
# Lookup part

sub c {
	my ($t, $c) = @_;
	$use_colors ? colored($t, $c) : $t;
}

sub wrapped {
	@_;
}

sub pretty {
	my $e = shift;
	my $out;

	my $w = $e->{words} || $e->{readings};
	$w and $out .= join(' / ', map { c($_, 'blue') } @$w) . "\n";
	$e->{kanji} and $out .= c($e->{kanji}, 'blue') . "\n";

	my %elems = (
		on => '音', kun => '訓', nanori => '名', english => '英',
		readings => '読', meanings => '英',
	);
	for my $f (qw/on kun nanori english readings meanings/) {
		next unless defined $e->{$f};
		$e->{words} or next if $f eq 'readings';
		$out .= '  ' . c($elems{$f}, 'green') . ' ';
		my $content = join("\n     ", wrapped(@{$e->{$f}}));
		$f eq 'kun' and $content =~ s/\.([^ ]*)/c("·$1", 'white')/e;
		$out .= "$content\n";
	}
	$out;
}

sub print_cut {
	my $n = shift;
	my $count = 0;
	for (@_) {
		print($_);
		$count++;
		if ($count == $n) {
			print("\n");
			$count = 0;
		}
	}
}

sub do_search {
	print("\n");
	for my $q (@_) {
		if ($q =~ /^[1-4]-[0-9]*-[0-9]*$/) {
			print(c("ー SKIP $q\n\n", 'yellow'));
			my @r = $kanjidic->skip_lookup($q);
			print_cut(20, @r);
			@r or print(c("Nothing found.", 'white'));
			print("\n\n");
			next;
		}

		my @kanjis = map { $kanjidic->lookup($_) } Wish::Edict2::kanjis($q);
		my @words = $edict->search($q);
		if ($show_homophones && $q =~ /\p{Han}/) {
			push(@words, $edict->homophones($q));
		}

		my $hl = quotemeta($q);
		print(c("ー $q\n\n", 'yellow'));
		$_ and print(pretty($_), "\n") for @kanjis;
		print(pretty($_) =~ s/$hl/c($&, 'red')/egr, "\n") for @words;
		@kanjis || @words or print(c("Nothing found.\n\n", 'white'));
	}
}

do_search(@ARGV);
