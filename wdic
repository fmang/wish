#!/usr/bin/perl -CA

use strict;
use warnings;
use utf8;

use Encode qw(decode encode);
use File::Path qw(make_path);
use Getopt::Long qw(:config no_auto_abbrev);
use Term::ANSIColor;
use Term::ReadLine;
use Wish::Edict2;
use Wish::KanjiDic;

my $usage = <<EOF;
Usage: wdic [OPTIONS] [QUERY...]
       wdic --load [--kanjidic FILE] [--edict FILE]
       wdic --help
EOF

my $help = <<EOF;
Options:
  -d, --database        Specify the location of the database directory.
  -l, --load            Open the database in write mode.
  --kanjidic            Load the specified KANJIDIC into the database.
  --edict               Load the specified EDICT2 into the databse.
  --[no]color           Enable or disable ANSI colors in the output.
  --[no]homophones      Also search for homophones.
  --[no]pager           Display the results in a pager.
                        Default pager is `less -R` if \$PAGER isn't defined.
  --help                Show this help.
EOF

my $dbdir = 'db';
my $load_mode;
my @kanjidic_files;
my @edict_files;
my $use_colors = -t STDOUT;
my $show_homophones = 1;
my $pager = $ENV{PAGER} || 'less -R';
my $use_pager = -t STDOUT;
my $show_help;

GetOptions(
	'database|d=s' => \$dbdir,
	'load|l' => \$load_mode,
	'kanjidic=s' => \@kanjidic_files,
	'edict=s' => \@edict_files,
	'color!' => \$use_colors,
	'homophones!' => \$show_homophones,
	'pager!' => \$use_pager,
	'help|h' => \$show_help,
) or die($usage);

if ($show_help) {
	print("$usage\n$help");
	exit(0);
}

if (!$load_mode and @kanjidic_files || @edict_files) {
	die("Cannot load a dictionary file without --load.\n");
}

if ($load_mode and @ARGV) {
	die("Please don't load and search at the same time.\n");
}

if ($load_mode && ! -d $dbdir) {
	print(STDERR "Creating the database directory $dbdir...\n");
	make_path($dbdir);
}

my $kanjidic = Wish::KanjiDic->new($dbdir, readonly => !$load_mode);
my $edict = Wish::Edict2->new($dbdir, readonly => !$load_mode);

$kanjidic && $edict or die("Couldn't open the dictionary database: $!.\n");

for my $file (@kanjidic_files) {
	print(STDERR "Loading KANJIDIC from $file...\n");
	my $s = $kanjidic->load($file);
	$s or warn("Couldn't load KANJIDIC from $file: $!.\n");
	$s and print(STDERR "Successfully loaded KANJIDIC from $file.\n");
}

for my $file (@edict_files) {
	print(STDERR "Loading EDICT2 from $file...\n");
	my $s = $edict->load($file);
	$s or warn("Couldn't load EDICT2 from $file: $!.\n");
	$s and print(STDERR "Successfully loaded EDICT2 from $file.\n");
}

if ($load_mode) {
	# work is done
	exit(0);
}

################################################################################
# Lookup part

sub c {
	my ($t, $c) = @_;
	$use_colors ? colored($t, $c) : $t;
}

sub pretty {
	my $e = shift;
	my $out;

	my $w = $e->{words} || $e->{readings};
	$w and $out .= join(' / ', map { c($_, 'blue') } @$w) . "\n";
	$e->{kanji} and $out .= c($e->{kanji}, 'blue') . "\n";

	my %elems = (
		on => '音', kun => '訓', nanori => '名', english => '英',
		readings => '読', meanings => '英',
	);
	for my $f (qw/on kun nanori english readings meanings/) {
		next unless defined $e->{$f};
		$e->{words} or next if $f eq 'readings';
		$out .= '  ' . c($elems{$f}, 'green') . ' ';
		my $content = join("\n     ", @{$e->{$f}});
		$f eq 'kun' and $content =~ s/\.([^ ]*)/c("·$1", 'white')/e;
		$out .= "$content\n";
	}
	$out;
}

sub cut {
	my $n = shift;
	my $count = 0;
	my $out;
	for (@_) {
		$out .= $_;
		$count++;
		if ($count == $n) {
			$out .= "\n";
			$count = 0;
		}
	}
	$out;
}

sub compare_entries {
	my $wa = $a->{words} ? $a->{words}->[0] : $a->{readings}->[0];
	my $wb = $b->{words} ? $b->{words}->[0] : $b->{readings}->[0];
	length($wa) <=> length($wb) || $wa cmp $wb
}

sub highlight {
	my ($txt, $hl) = @_;
	$hl = quotemeta($hl);
	$txt =~ s/(\033[^m]*m)([^\033]*)($hl)/$1.$2.c($3, 'red').$1/egr;
}

sub do_search {
	open(OUT, $use_pager ? "| $pager" : '>&STDOUT') or open(OUT, '>&STDOUT');
	binmode(OUT, ':utf8');
	print(OUT "\n");
	for my $q (@_) {
		if ($q =~ /^[1-4]-[0-9]*-[0-9]*$/) {
			print(OUT c("ー SKIP $q\n\n", 'yellow'));
			my @r = $kanjidic->skip_lookup($q);
			print(OUT cut(20, @r));
			@r or print(OUT c("Nothing found.", 'white'));
			print(OUT "\n\n");
			next;
		}

		my @kanjis = map { $kanjidic->lookup($_) } Wish::Edict2::kanjis($q);
		my @words = sort compare_entries $edict->search($q);
		if ($show_homophones && $q =~ /\p{Han}/) {
			push(@words, $edict->homophones($q));
		}

		print(OUT c("ー $q\n\n", 'yellow'));
		$_ and print(OUT pretty($_), "\n") for @kanjis;
		$_ and print(OUT highlight(pretty($_), $q), "\n") for @words;
		@kanjis || @words or print(OUT c("Nothing found.\n\n", 'white'));
	}
	close(OUT);
}


if (@ARGV) {
	do_search(@ARGV);
} elsif (-t STDIN) {
	my $term = Term::ReadLine->new('wdic', \*STDIN, \*STDOUT);
	$term->ornaments(0);
	while (defined ($_ = $term->readline(c('検索> ', 'blue')))) {
		$_ = decode('UTF-8', $_);
		my @qs = split or next;
		do_search(@qs);
		$term->addhistory($_);
	}
	print("Bye.\n");
} else {
	binmode(STDIN, ':encoding(UTF-8)');
	do_search(map { split } <STDIN>);
}
