#!/usr/bin/perl -CA

use strict;
use warnings;
use utf8;

use File::Path qw(make_path);
use Getopt::Long qw(:config no_auto_abbrev);
use Term::ANSIColor;
use Term::ReadKey;
use Text::Wrap;
use Wish::Edict2;
use Wish::KanjiDic;

binmode(STDOUT, ":utf8");

my $dbdir = 'db';
my $load_mode;
my @kanjidic_files;
my @edict_files;

GetOptions(
	'database|db|d=s' => \$dbdir,
	'load|l' => \$load_mode,
	'kanjidic=s' => \@kanjidic_files,
	'edict=s' => \@edict_files,
);

if (!$load_mode and @kanjidic_files || @edict_files) {
	die("Cannot load a dictionary file without --load.\n");
}

if ($load_mode and @ARGV) {
	die("Please don't load and search at the same time.\n");
}

if (!$load_mode and !@ARGV) {
	print("Nothing to do.\n");
	exit(0);
}

if ($load_mode && ! -d $dbdir) {
	print(STDERR "Creating the database directory $dbdir...\n");
	make_path($dbdir);
}

my $kanjidic = Wish::KanjiDic->new($dbdir, readonly => !$load_mode);
my $edict = Wish::Edict2->new($dbdir, readonly => !$load_mode);

$kanjidic && $edict or die("Couldn't open the dictionary database: $!.\n");

for my $file (@kanjidic_files) {
	print(STDERR "Loading KANJIDIC from $file...\n");
	my $s = $kanjidic->load($file);
	$s or warn("Couldn't load KANJIDIC from $file: $!.\n");
	$s and print(STDERR "Successfully loaded KANJIDIC from $file.\n");
}

for my $file (@edict_files) {
	print(STDERR "Loading EDICT2 from $file...\n");
	my $s = $edict->load($file);
	$s or warn("Couldn't load EDICT2 from $file: $!.\n");
	$s and print(STDERR "Successfully loaded EDICT2 from $file.\n");
}

if ($load_mode) {
	# work is done
	exit(0);
}

################################################################################
# Lookup part

local $Text::Wrap::columns = (GetTerminalSize())[0];

sub c {
	my ($t, $c) = @_;
	-t STDOUT ? colored($t, $c) : $t;
}

sub print_kanji {
	my $k = shift;
	print(c($k->{kanji}, 'blue'));
	my $prefix = ' ';
	my %elems = (on => '音', kun => '訓', nanori => '名', english => '英');
	for my $f (qw/on kun nanori english/) {
		next unless defined $k->{$f};
		print($prefix, c($elems{$f}, 'green'));
		$prefix = ' ';
		for (@{$k->{$f}}) {
			$f eq 'kun' and s/\.(.*)$/c("·$1", 'white')/e;
			print($prefix, "$_\n");
			$prefix = '      ';
		}
		$prefix = '   ';
	}
}

sub print_cut {
	my $n = shift;
	my $count = 0;
	for (@_) {
		print($_);
		$count++;
		if ($count == $n) {
			print("\n");
			$count = 0;
		}
	}
}

sub print_entry {
	my $e = shift;
	my $w = $e->{words} || $e->{readings};
	my $r = $e->{words} ? $e->{readings} : undef;
	$w or return;
	print(join(' / ', map { c($_, 'blue') } @$w), "\n");
	$r and print(c('   読 ', 'green'), join('  ', @$r), "\n");
	$e->{meanings} and print(color('green'), wrap('   英 ', '      ',
		color('reset') . join(' — ', @{$e->{meanings}}), "\n"
	));
	print("\n");
}

print("\n");

for my $q (@ARGV) {
	if ($q =~ /^[1-4]-[0-9]*-[0-9]*$/) {
		print(c("ー SKIP $q\n\n", 'yellow'));
		my @r = $kanjidic->skip_lookup($q);
		print_cut(20, @r);
		@r or print(c("Nothing found.", 'white'));
		print("\n\n");
		next;
	}
	print(c("ー $q\n\n", 'yellow'));
	my $found = 0;
	for (sort(Wish::Edict2::kanjis($q))) {
		if (my $k = $kanjidic->lookup($_)) {
			print_kanji($k);
			print("\n");
			$found = 1;
		}
	}
	my @words = $edict->search($q);
	$found ||= @words;
	print_entry($_) for @words;
	$found or print(c("Nothing found.\n\n", 'white'));
}
